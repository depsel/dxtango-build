{
  "version": 3,
  "sources": ["../../../src/app/components/ClientOnly.tsx", "../../../src/code.client/hooks/useHydrated.ts"],
  "sourcesContent": ["// REMIX HMR BEGIN\nif (!window.$RefreshReg$ || !window.$RefreshSig$ || !window.$RefreshRuntime$) {\n  console.warn('remix:hmr: React Fast Refresh only works when the Remix compiler is running in development mode.');\n} else {\n  var prevRefreshReg = window.$RefreshReg$;\n  var prevRefreshSig = window.$RefreshSig$;\n  window.$RefreshReg$ = (type, id) => {\n    window.$RefreshRuntime$.register(type, \"\\\"src/app/components/ClientOnly.tsx\\\"\" + id);\n  }\n  window.$RefreshSig$ = window.$RefreshRuntime$.createSignatureFunctionForTransform;\n}\nvar _s = $RefreshSig$();\nimport * as __hmr__ from \"remix:hmr\";\nif (import.meta) {\n  import.meta.hot = __hmr__.createHotContext(\n  //@ts-expect-error\n  \"src/app/components/ClientOnly.tsx\");\n  import.meta.hot.lastModified = \"1711947452192.917\";\n}\n// REMIX HMR END\n\nimport { useHydrated } from '#/hooks/useHydrated';\n/**\n * Render the children only after the JS has loaded client-side. Use an optional\n * fallback component if the JS is not yet loaded.\n *\n * Example: Render a Chart component if JS loads, renders a simple FakeChart\n * component server-side or if there is no JS. The FakeChart can have only the\n * UI without the behavior or be a loading spinner or skeleton.\n * ```tsx\n * return (\n *   <ClientOnly fallback={<FakeChart />}>\n *     {() => <Chart />}\n *   </ClientOnly>\n * );\n * ```\n */\nexport function ClientOnly({\n  children,\n  fallback = null\n}) {\n  _s();\n  return useHydrated() ? <>{children}</> : <>{fallback}</>;\n}\n_s(ClientOnly, \"C0k0BFxzCOs2/7WvjhO8H2Jzc4g=\", false, function () {\n  return [useHydrated];\n});\n_c = ClientOnly;\nvar _c;\n$RefreshReg$(_c, \"ClientOnly\");\n\nwindow.$RefreshReg$ = prevRefreshReg;\nwindow.$RefreshSig$ = prevRefreshSig;", "import { useSyncExternalStore } from \"react\";\n\nfunction subscribe() {\n\treturn () => {};\n}\n\n/**\n * Return a boolean indicating if the JS has been hydrated already.\n * When doing Server-Side Rendering, the result will always be false.\n * When doing Client-Side Rendering, the result will always be false on the\n * first render and true from then on. Even if a new component renders it will\n * always start with true.\n *\n * Example: Disable a button that needs JS to work.\n * ```tsx\n * let hydrated = useHydrated();\n * return (\n *   <button type=\"button\" disabled={!hydrated} onClick={doSomethingCustom}>\n *     Click me\n *   </button>\n * );\n * ```\n */\nexport function useHydrated() {\n\treturn useSyncExternalStore(\n\t\tsubscribe,\n\t\t() => true,\n\t\t() => false,\n\t);\n}"],
  "mappings": ";;;;;;;;;;;;;;;AAAA;;;ACAA;AAAA,mBAAqC;AAErC,SAAS,YAAY;AACpB,SAAO,MAAM;AAAA,EAAC;AACf;AAmBO,SAAS,cAAc;AAC7B,aAAO;AAAA,IACN;AAAA,IACA,MAAM;AAAA,IACN,MAAM;AAAA,EACP;AACD;;;ADayB;AAzCzB,IAAI,CAAC,OAAO,gBAAgB,CAAC,OAAO,gBAAgB,CAAC,OAAO,kBAAkB;AAC5E,UAAQ,KAAK,kGAAkG;AACjH,OAAO;AACD,mBAAiB,OAAO;AACxB,mBAAiB,OAAO;AAC5B,SAAO,eAAe,CAAC,MAAM,OAAO;AAClC,WAAO,iBAAiB,SAAS,MAAM,wCAA0C,EAAE;AAAA,EACrF;AACA,SAAO,eAAe,OAAO,iBAAiB;AAChD;AANM;AACA;AAMN,IAAI,KAAK,aAAa;AAEtB,IAAI,aAAa;AACf,cAAY,MAAc;AAAA;AAAA,IAE1B;AAAA,EAAmC;AACnC,cAAY,IAAI,eAAe;AACjC;AAmBO,SAAS,WAAW;AAAA,EACzB;AAAA,EACA,WAAW;AACb,GAAG;AACD,KAAG;AACH,SAAO,YAAY,IAAI,sFAAG,YAAH;AAAA;AAAA;AAAA;AAAA,SAAY,IAAM,sFAAG,sBAAH;AAAA;AAAA;AAAA;AAAA,SAAY;AACvD;AACA,GAAG,YAAY,gCAAgC,OAAO,WAAY;AAChE,SAAO,CAAC,WAAW;AACrB,CAAC;AACD,KAAK;AACL,IAAI;AACJ,aAAa,IAAI,YAAY;AAE7B,OAAO,eAAe;AACtB,OAAO,eAAe;",
  "names": []
}
